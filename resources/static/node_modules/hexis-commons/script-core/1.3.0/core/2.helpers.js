/*------------------------------------------------------------------------------------
  requestAnimationFrame polyfill
------------------------------------------------------------------------------------*/
window.requestAnimationFrame = window.requestAnimationFrame
  || window.webkitRequestAnimationFrame
  || window.mozRequestAnimationFrame
  || window.msRequestAnimationFrame
  || function(callback) { return setTimeout(callback, 1000 / 60); };



/*------------------------------------------------------------------------------------
  matches polyfill
------------------------------------------------------------------------------------*/
Element.prototype.matches = (Element.prototype.matches || Element.prototype.mozMatchesSelector
  || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector
  || Element.prototype.webkitMatchesSelector || Element.prototype.webkitMatchesSelector);



/*------------------------------------------------------------------------------------
  Finds the closest parent of an element, similar to jQuery.closest()

  - You must specify a wantedSelector e.g. "div.class"
  - You can be performant and specify an optional limiterSelector. Without it, this
    will check for matches all the way down to the body element
  - If matched, returns the wanted element
  - If not matched, return false
------------------------------------------------------------------------------------*/
function closest(target, wantedSelector, limiterSelector) {
  var current = target;
  var limiterSelector = limiterSelector || 'body';

  // Iterate through parent elements until you reach some end
  while (current.matches(wantedSelector)!==true && current.matches(limiterSelector)!==true && current.matches('body')!==true) {
    current = current.parentElement;
  }

  // If we get to the limiterSelectorer but find no matches, this is false
  if (current.matches(limiterSelector)===true) {
    current = false;
  }

  // If everything so far passes, return the element as true
  return current;
}



/*------------------------------------------------------------------------------------
  Encapsulation to make sure your callback code runs only if/when documentReady
  or windowLoad event has fired (even after it has passed)
------------------------------------------------------------------------------------*/
window.whenReady = function(callback) {
  if (App.documentReady === true) {
    callback();
  } else {
    $(document).ready(function(){
      callback();
    });
  }
};

window.whenLoaded = function(callback) {
  if (App.windowLoad === true) {
    callback();
  } else {
    $(window).on('load', function(){
      callback();
    });
  }
};



/*------------------------------------------------------------------------------------
  A general encapsulation to wait for a boolean property (or an object containing
  multiple booleans) to become TRUE

  An example usage scenario is to wait for critical resources to load, before calling
  some secondary / less important resources.
------------------------------------------------------------------------------------*/
window.whenTrue = function(path, callback) {
  var callback = callback || function(){};
  var loadPath = path.split('.');
  var mustBeTrue;

  // ARE YOU NOT ENTERTAINED !?
  if (loadPath.length === 1) {
    mustBeTrue = App.load[loadPath[0]];
  } else if (loadPath.length === 2) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]];
  } else if (loadPath.length === 3) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]][loadPath[2]];
  } else if (loadPath.length === 4) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]][loadPath[2]][loadPath[3]];
  } else if (loadPath.length > 4) {
    console.error('whenTrue(); ERROR: Entertainment level is too damn high!');
  }

  // We use an external function to do this specific work and call back if it return true
  if (ifTrue(mustBeTrue)) {
    callback();
  }

  // Otherwise, we check back here again after a delay
  else {
    setTimeout(function(){
      whenTrue(path, callback);
    }, 50);
  }
};


window.ifTrue = function(mustBeTrue) {

  // Handle an object (every key must be TRUE to pass)
  if (typeof mustBeTrue === 'object') {

    // Empty object will qualify automatically as TRUE
    if (Object.keys(mustBeTrue).length !== 0) {
      for (var property in mustBeTrue) {
        if (mustBeTrue.hasOwnProperty(property)) {
          if (mustBeTrue[property] !== true) {
            return false;
          }
        }
      }
    }

    // If everything passes up to here, return true
    return true;
  }

  // Handle a direct boolean
  else if (typeof mustBeTrue === 'boolean') {
    if (mustBeTrue === true) {
      return true;
    } else {
      return false;
    }
  }

  // String is not allowed
  else if (typeof mustBeTrue === 'string') {
    console.error('whenTrue(); ERROR: String is not allowed. Must be a boolean or object...');
    return false;
  }

  // Fallback error
  else {
    console.error('whenTrue(); ERROR: Incompatible value type!');
    return false;
  }
};



/*------------------------------------------------------------------------------------
  Get active media query
------------------------------------------------------------------------------------*/
App.checkMediaQuery = function (query, explicit) {
  all = [];

  // Default to coarse
  var explicit = explicit || false;

  // Get all active media queries
  if ($('#screenSize').css('font-family') != undefined) {
    var all = $('#screenSize').css('font-family').replace(/['"]+/g, '').split(', ');
    var last = all[all.length-1];
  }

  // Check for matches
  if( explicit === true && all[all.length-1] === query ){ return true; }
  else if( explicit === false ){
    for (var i = 0; i < all.length; i++) {
      if( all.indexOf(query) > -1 === true ){ return true; }
    }
  }

  // If no success is returned, return false
  return false;
}



/*------------------------------------------------------------------------------------
  Light scroll
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightScroll = function(callback, delay){
  var timer,
      delay = delay || (1000 / 15),
      scrollCounter = 0;

  // Listen for scroll events on window and any custom scrollable element
  // window.onscroll = function (e) { parseScroll(e); }
  $(window).on('scroll touchmove', function(e) { parseScroll(e); });
  $('[data-scrollable]').on('scroll touchmove', function(e) { parseScroll(e); });

  // Main parsing function
  function parseScroll(e) {

    // Log that user has scrolled at least once
    ux.events.userHasScrolled = true;

    // Count scroll ticks and force callback execution on a specific count
    scrollCounter++;
    if( scrollCounter > 8 ){
      requestAnimationFrame(callback);
      scrollCounter = 0;
      timer = false;
      return false;
    }

    // If scroll counters are low, proceed with regular Timeout
    clearTimeout(timer);
    timer = setTimeout(function(){
      scrollCounter = 0;
      requestAnimationFrame(callback);
    }, delay);
  }
};



/*------------------------------------------------------------------------------------
  Light resize
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightResize = function(callback, delay) {
  var timer;
  var delay = delay || (1000 / 10);
  $(window).on('resize', function(e) {
    clearTimeout(timer);
    timer = setTimeout(function(){
      requestAnimationFrame(callback);
    }, delay);
  });
};



/*------------------------------------------------------------------------------------
  Update user info on resize event
------------------------------------------------------------------------------------*/
App.getViewportMetadata = function(){

  // Width & Height
  // We don't check "window" for screen size due to iOS browser bugs
  ux.viewport.width = $('#screenSize').width();
  ux.viewport.height = $('#screenSize').height();

  // Visible range
  ux.viewport.visible = {
    from: ux.scroll.offset,
    to: ux.scroll.offset + ux.viewport.height
  };

  // Check #screenSize element validity
  if ($('#screenSize').css('font-family') === undefined) {
    console.error('App.getViewportMetadata(): Unable to read screen size! Check the #screenSize element');
    return false;
  }

  // Current screen size (media query)
  var all = $('#screenSize').css('font-family').replace(/['"]+/g, '').split(', ');
  var last = all[all.length-1];
  ux.screenSize.explicit = last;

  // Coarse screen size ignores sub-sizes. This makes e.g., "smallPlus" a more general "small" size.
  if ( App.checkMediaQuery('small') === true ){ ux.screenSize.coarse = 'small'; }
  if ( App.checkMediaQuery('medium') === true ){ ux.screenSize.coarse = 'medium'; }
  if ( App.checkMediaQuery('large') === true ){ ux.screenSize.coarse = 'large'; }

}

// Get initial viewportMetadata on documentLoad
whenReady(function viewportMetadata(){
  App.getViewportMetadata();
});

// Update viewportMetadata on resize
App.lightResize(App.getViewportMetadata, (1000 / 30));



/*------------------------------------------------------------------------------------
  Update user info on scroll event
------------------------------------------------------------------------------------*/
App.getScrollMetadata = function(){
  var treshold = 50;

  // Set scroll offset
  ux.scroll.offsetPrevious = ux.scroll.offset;
  ux.scroll.offset = $(window).scrollTop();

  // We compare distance traveled with a defined treshold and report scroll direction
  if( (ux.scroll.offset - ux.scroll.offsetPrevious) > treshold ){
    ux.scroll.direction = 'down';
  } else if( (ux.scroll.offsetPrevious - ux.scroll.offset) > treshold ){
    ux.scroll.direction = 'up';
  }

  // Update viewport visibility values
  ux.viewport.visible = {
    from: ux.scroll.offset,
    center: ux.scroll.offset + (ux.viewport.height / 2),
    to: ux.scroll.offset + ux.viewport.height
  };
}

// Get initial scrollMetadata on documentLoad
queue.documentLoad.push(function scrollMetadata(){
  App.getScrollMetadata();
});

// Update scrollMetadata on scroll
App.lightScroll(App.getScrollMetadata, (1000 / 30));



/*------------------------------------------------------------------------------------
  Get scrollbar width
------------------------------------------------------------------------------------*/
queue.documentLoad.push(function scrollbarWidth(){

  // Create test elements
  var parent = $('<div style="width:100px;height:100px;overflow-y:scroll;visibility:hidden;"><div style="width:100%;"><div/></div>').appendTo('body');
  var child = parent.children().first();

  // Calculate scrollbar width
  ux.scroll.scrollbarWidth = 100 - child.width();

  // Calculate scrollbar position (right-to-left languages have scrollbar on the other side)
  if (child.offset().left !== parent.offset().left) {
    ux.scroll.scrollbarPosition = 'left';
  } else {
    ux.scroll.scrollbarPosition = 'right';
  }

  // Remove DOM elements
  parent.remove();
});



/*------------------------------------------------------------------------------------
  Check if element is currently visible on the screen
------------------------------------------------------------------------------------*/
App.checkIfVisible = function(el, tresholdMultiplier) {

  // Default treshold and multiplier
  var tresholdMultiplier = tresholdMultiplier || 1;
  var treshold = ux.viewport.height * tresholdMultiplier;

  // Increase the treshold even further for smaller devices, since the user will
  // usually be scrolling much faster.
  if (
    App.checkMediaQuery('small', true) === true ||
    App.checkMediaQuery('smallPlus', true) === true ||
    App.checkMediaQuery('medium', true) === true
  ){
    treshold = treshold * 1.5;
  }

  // Additionally, increase the treshold if device is in landscape mode
  if (ux.viewport.width > (ux.viewport.height * 2)) {
    treshold = treshold * 1.5;
  }

  var elem = {
    offset: $(el).offset(),
    width: $(el).width(),
    height: $(el).height()
  };

  if (
    (elem.offset.top + elem.height) >= (ux.scroll.offset - treshold) &&
    elem.offset.top <= (ux.viewport.visible.to + treshold)
  ){
    return true;
  } else {
    return false;
  }
}
