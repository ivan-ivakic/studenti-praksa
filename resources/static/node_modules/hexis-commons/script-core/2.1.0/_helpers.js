/*------------------------------------------------------------------------------------
  Finds the first matched parent in native javascript.
  Similar to jQuery.closest();

  - First you provide a starting point / target element (usually event.target)
  - You must specify a wanted selector for the parent, e.g. "div.class" or an array
    of selectors like ['.selector1', '#selector2', '[selector3]']
  - You can be performant and specify an optional limiterSelector. Without it, this
    will check for matches all the way up to the root/body element
  - If matched, returns the element itself
  - If not matched, return false
------------------------------------------------------------------------------------*/
function closest(target, wantedSelector, limiterSelector) {
  var current = target;
  var limiterSelector = limiterSelector || 'body';
  var match = false;

  // Iterate through parent elements until you reach some end
  while (match === false) {

    // If this is the bubbling limit...
    if (current.matches(limiterSelector)===true || current.matches('body')===true) {
      if (current.matches(wantedSelector)===true) {
        match = current;
      } else {
        return false;
      }
    }

    // Simple string match first...
    if (typeof wantedSelector==='string' && current.matches(wantedSelector)===true) {
      match = current;
    }

    // In case, we're dealing with an array of possible matches, check each selector individually..
    else if (typeof wantedSelector==='object') {
      wantedSelector.forEach(function(currentSelector){
        if (current.matches(currentSelector)===true) {
          match = current;
        }
      });
    }

    // If no matches, move up the parent tree...
    current = current.parentElement;
  }

  // If everything so far passes, return the element
  return match;
}



/*------------------------------------------------------------------------------------
  Simple NodeList to array conversion
------------------------------------------------------------------------------------*/
window.array = function(NodeList) {
  return Array.prototype.slice.call(NodeList);
}



/*------------------------------------------------------------------------------------
  Detects if callback exists and returns a blank function if it does not
------------------------------------------------------------------------------------*/
App.callback = function(callback) {
  if (callback === null || callback === undefined || callback === false) {
    return function(){};
  } else {
    return callback;
  }
}



/*------------------------------------------------------------------------------------
  Simple append / prepend functions.
  Accepts html string, e.g. "<div class='foo'>bar</div>"
------------------------------------------------------------------------------------*/
function appendix(html) {
  if (typeof html === 'string') {
    var p = document.createElement('div');
    p.innerHTML = html;
    return array(p.children);
  }
  else if (typeof html === 'object') {
    return [html];
  }
}

window.append = function(html, targetElement) {
  var targetElement = targetElement || document.body;
  appendix(html).forEach(function(node){
    targetElement.appendChild(node);
  });
}

window.prepend = function(html, targetElement) {
  var targetElement = targetElement || document.body;
  appendix(html).forEach(function(node){
    targetElement.insertBefore(node, targetElement);
  });
}



/*------------------------------------------------------------------------------------
  Handle clicks and taps on mobile without delay
  Currently uses Hammer.js as a dependency
------------------------------------------------------------------------------------*/
window.handleClick = function(target, callback) {

  target.addEventListener('click', function(e){
    e.preventDefault();
    callback(e);
  }, false);

  // Handle taps
  // Code is inspired by: https://github.com/filamentgroup/tappy
  var startTime, cancel, startX, startY, currentX, currentY;
  var scrollTolerance = 8;

  target.addEventListener('touchstart', function(e){
    console.log('-----');
    var touches = e.touches || e.targetTouches;
    startTime = (new Date()).getTime();

    // Break if multiple fingers are detected...
    if (touches.length > 1) {
      return false;
    }

    // Log starting positions...
    startX = touches[0].pageX;
    startY = touches[0].pageY;
  }, false);

  target.addEventListener('touchmove', function(e){
    if (!cancel) {
      var touches = e.touches || e.targetTouches;
      currentX = touches[0].pageX;
      currentY = touches[0].pageY;
      if (Math.abs(startY - currentY) > scrollTolerance || Math.abs(startX - currentX) > scrollTolerance) {
        cancel = true;
      }
    }
  }, false);

  target.addEventListener('touchend', function(e){
    var timePressed = (new Date()).getTime() - startTime;
    if (timePressed > 500) {
      cancel = false;
      return;
    }

    // Make sure no modifiers are present. http://www.jacklmoore.com/notes/click-events/
    if ((e.which && e.which > 1) || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey) {
      cancel = false;
      return;
    }

    // Break if we have logged cancellation
    if (cancel === true) {
      cancel = false;
      return;
    }

    // If everything so far has passed, trigger callback
    e.preventDefault();
    callback(e);
  }, false);
};



/*------------------------------------------------------------------------------------
  Encapsulation to make sure your callback code runs only if/when documentReady
  or windowLoad event has fired (even after it has passed)
------------------------------------------------------------------------------------*/
window.whenReady = function(callback) {
  if (App.documentReady === true) {
    callback();
  } else {
    setTimeout(function(){
      whenReady(callback);
    }, 50);
  }
};

window.whenLoaded = function(callback) {
  if (App.windowLoad === true) {
    callback();
  } else {
    setTimeout(function(){
      whenLoaded(callback);
    }, 100);
  }
};



/*------------------------------------------------------------------------------------
  A general encapsulation to wait for a boolean property (or an object containing
  multiple booleans) to become TRUE

  An example usage scenario is to wait for critical resources to load, before calling
  some secondary / less important resources.
------------------------------------------------------------------------------------*/
window.whenTrue = function(path, callback) {
  var callback = callback || function(){};
  var loadPath = path.split('.');
  var mustBeTrue;

  // ARE YOU NOT ENTERTAINED !?
  if (loadPath.length === 1) {
    mustBeTrue = App.load[loadPath[0]];
  } else if (loadPath.length === 2) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]];
  } else if (loadPath.length === 3) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]][loadPath[2]];
  } else if (loadPath.length === 4) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]][loadPath[2]][loadPath[3]];
  } else if (loadPath.length > 4) {
    console.error('whenTrue(); ERROR: Entertainment level is too damn high!');
  }

  // We use an external function to do this specific work and call back if it return true
  if (ifTrue(mustBeTrue)) {
    callback();
  }

  // Otherwise, we check back here again after a delay
  else {
    setTimeout(function(){
      whenTrue(path, callback);
    }, 50);
  }
};


window.ifTrue = function(mustBeTrue) {

  // Handle an object (every key must be TRUE to pass)
  if (typeof mustBeTrue === 'object') {

    // Empty object will qualify automatically as TRUE
    if (Object.keys(mustBeTrue).length !== 0) {
      for (var property in mustBeTrue) {
        if (mustBeTrue.hasOwnProperty(property)) {
          if (mustBeTrue[property] !== true) {
            return false;
          }
        }
      }
    }

    // If everything passes up to here, return true
    return true;
  }

  // Handle a direct boolean
  else if (typeof mustBeTrue === 'boolean') {
    if (mustBeTrue === true) {
      return true;
    } else {
      return false;
    }
  }

  // String is not allowed
  else if (typeof mustBeTrue === 'string') {
    console.error('whenTrue(); ERROR: String is not allowed. Must be a boolean or object...');
    return false;
  }

  // Fallback error
  else {
    console.error('whenTrue(); ERROR: Incompatible value type!');
    return false;
  }
};



/*------------------------------------------------------------------------------------
  Light scroll
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightScroll = function(callback, delay) {
  var timer;
  var delay = delay || 60;
  var scrollCounter = 0;
  var scrollTrigger = 5;
  var touchCounter = 0;
  var touchTrigger = 25;
  var isTouchDevice = false;

  // Listen for general scroll events...
  window.addEventListener('scroll', function(e){
    if (touchCounter === 0) { scrollTrigger = 5; } else { scrollTrigger = 25; }
    if (scrollCounter > scrollTrigger){ parseScroll(e, true); }
    else { scrollCounter++; parseScroll(e, false); }
  }, true);

  // Listen to touchmove events as fallback
  window.addEventListener('touchmove', function(e){
    if (touchCounter > touchTrigger){ parseScroll(e, true); }
    else { touchCounter++; parseScroll(e, false); }
  }, true);

  // Scroll parser
  function parseScroll(e, counterTrigger) {

    // Log that user has scrolled at least once
    ux.events.userHasScrolled = true;

    // If trigger is true, callback immediatelly
    if (counterTrigger){
      requestAnimationFrame(callback);
      scrollCounter = 0;
      touchCounter = 0;
      timer = false;
      return;
    }

    // If scroll counters are low, proceed with regular Timeout
    clearTimeout(timer);
    timer = setTimeout(function(){
      scrollCounter = 0;
      requestAnimationFrame(callback);
    }, delay);
  }
};



/*------------------------------------------------------------------------------------
  Light resize
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightResize = function(callback, delay) {
  var timer;
  var delay = delay || 100;
  window.addEventListener('resize', function(){
    clearTimeout(timer);
    timer = setTimeout(function(){
      requestAnimationFrame(callback);
    }, delay);
  });
};



/*------------------------------------------------------------------------------------
  Get scrollbar width
------------------------------------------------------------------------------------*/
whenReady(function scrollbarWidth(){

  // Create a tester element
  var html = '<div id="scrollTester" style="width:100px;height:100px;overflow-y:scroll;visibility:hidden;"><div style="width:100%;"><div/></div>';
  append(html, document.body);

  // Anchor working elements
  var tester = document.getElementById('scrollTester');
  var child = tester.querySelector('div');

  // Calculate scrollbar width
  ux.scroll.scrollbarWidth = 100 - child.offsetWidth;

  // Calculate scrollbar position (right-to-left languages have scrollbar on the other side)
  if (tester.getBoundingClientRect().left !== child.getBoundingClientRect().left) {
    ux.scroll.scrollbarPosition = 'left';
  } else {
    ux.scroll.scrollbarPosition = 'right';
  }

  // Remove the tester from the DOM
  document.body.removeChild(tester);
});



/*------------------------------------------------------------------------------------
  Update user info on scroll event
------------------------------------------------------------------------------------*/
App.getScrollMetadata = function(){
  var treshold = 50;

  // Set scroll offset
  ux.scroll.offsetPrevious = ux.scroll.offset;
  ux.scroll.offset = document.documentElement.scrollTop || document.body.scrollTop;

  // We compare distance traveled with a defined treshold and report scroll direction
  if( (ux.scroll.offset - ux.scroll.offsetPrevious) > treshold ){
    ux.scroll.direction = 'down';
  } else if( (ux.scroll.offsetPrevious - ux.scroll.offset) > treshold ){
    ux.scroll.direction = 'up';
  }

  // Update viewport visibility values
  ux.viewport.visible = {
    from: ux.scroll.offset,
    center: ux.scroll.offset + (ux.viewport.height / 2),
    to: ux.scroll.offset + ux.viewport.height
  };
}

// Get initial scrollMetadata on documentLoad
whenReady(function scrollMetadata(){
  App.getScrollMetadata();
});

// Update scrollMetadata on scroll
App.lightScroll(App.getScrollMetadata, 20);



/*------------------------------------------------------------------------------------
  Update user info on resize event
------------------------------------------------------------------------------------*/
App.getViewportMetadata = function(){

  // Refresh scroll metadata first
  App.getScrollMetadata();

  // Find the helper element
  var screenHelper = document.getElementById('screenSize');

  // Return error if no helper element is found
  if (screenHelper===null || screenHelper===undefined) {
    console.error('App.getViewportMetadata(): Unable to read screen size! Check the #screenSize element');
    return false;
  }

  // Get dimensions
  // We don't check "window" for screen size due to iOS browser bugs
  ux.viewport.width = screenHelper.offsetWidth;
  ux.viewport.height = screenHelper.offsetHeight;

  // Parse device size
  var rawSizes = window.getComputedStyle(screenHelper).getPropertyValue('font-family');
  ux.device.screenSize.all = rawSizes.replace(/['"]+/g, '').split(', ');
  ux.device.screenSize.last = ux.device.screenSize.all[ux.device.screenSize.all.length-1];

  // Parse device resolution
  var rawResolution = window.getComputedStyle(screenHelper).getPropertyValue('content');
  ux.device.resolution = rawResolution.replace(/['"]+/g, '').split(', ');
}

// Get initial viewportMetadata on documentLoad
whenReady(function viewportMetadata(){
  App.getViewportMetadata();
});

// Update viewportMetadata on resize
App.lightResize(App.getViewportMetadata, 40);



/*------------------------------------------------------------------------------------
  Get active media query
------------------------------------------------------------------------------------*/
App.checkMediaQuery = function (query, explicit) {
  var match = false;

  // Default to coarse
  var explicit = explicit || false;

  // If the first character is "@", then we're matching resolutions...
  if (query.charAt(0) === '@') {
    for (var i=0; i < ux.device.resolution.length; i++) {
      if( ux.device.resolution.indexOf(query) > -1 === true ){
        match = true;
      }
    }
  }

  // Otherwise, check device sizes...
  else {
    if( explicit === true && ux.device.screenSize.all[ux.device.screenSize.all.length-1] === query ){ match = true; }
    else if( explicit === false ){
      for (var i = 0; i < ux.device.screenSize.all.length; i++) {
        if( ux.device.screenSize.all.indexOf(query) > -1 === true ){ match = true; }
      }
    }
  }

  // If matches are found, return false
  // if(App.verbose){ console.log('checkMediaQuery(' + query + ') = ' + match); }
  return match;
}



/*------------------------------------------------------------------------------------
  Check if element is currently visible on the screen
------------------------------------------------------------------------------------*/
App.checkIfVisible = function(el, tresholdMultiplier) {
  // if(App.verbose){ console.log('checkIfVisible', el); }

  // Default treshold and multiplier
  var tresholdMultiplier = tresholdMultiplier || 1;
  var treshold = ux.viewport.height * tresholdMultiplier;

  // Increase the treshold even further for smaller devices, since the user will
  // usually be scrolling much faster.
  if (
    App.checkMediaQuery('small', true) === true ||
    App.checkMediaQuery('smallPlus', true) === true ||
    App.checkMediaQuery('medium', true) === true
  ){
    treshold = treshold * 1.5;
  }

  // Additionally, increase the treshold if device is in landscape mode
  if (ux.viewport.width > ((ux.viewport.height) * 2)) {
    treshold = treshold * 1.5;
  }

  var bounds = el.getBoundingClientRect();

  if (
    (bounds.top + bounds.height) >= (0 - treshold) &&
    bounds.top < (ux.viewport.height + treshold)
  ){
    return true;
  } else {
    return false;
  }
}


/*------------------------------------------------------------------------------------
  setTimeout() abstraction which collapses any timeout to 0ms if the browser does
  not support css transitions
------------------------------------------------------------------------------------*/
window.animationTimeout = function(timeout, callback) {

  // Get transition support data the first time
  if (ux.support.transitions === undefined) {
    if (document.getElementsByTagName('html')[0].classList.contains('transitions')) {
      ux.support.transitions = true;
    } else {
      ux.support.transitions = false;
    }
  }

  // Make the check
  if (ux.support.transitions === true) {
    setTimeout(callback, timeout);
  } else {
    callback();
  }
}


/*------------------------------------------------------------------------------------
  Generate a random GUID (global unique identifier)
------------------------------------------------------------------------------------*/
App.guid = function() {
  return (Math.random().toString(36).slice(2));
}
