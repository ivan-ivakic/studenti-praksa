/*------------------------------------------------------------------------------------
  requestAnimationFrame polyfill
------------------------------------------------------------------------------------*/
window.requestAnimationFrame = window.requestAnimationFrame
  || window.webkitRequestAnimationFrame
  || window.mozRequestAnimationFrame
  || window.msRequestAnimationFrame
  || function(callback) { return setTimeout(callback, 1000 / 60); };



/*------------------------------------------------------------------------------------
  Encapsulation to make sure your callback code runs only if/when documentReady
  or windowLoad event has fired (even after it has passed)
------------------------------------------------------------------------------------*/
window.whenReady = function(callback) {
  if (App.documentReady === true) {
    callback();
  } else {
    $(document).ready(function(){
      callback();
    });
  }
};

window.whenLoaded = function(callback) {
  if (App.windowLoad === true) {
    callback();
  } else {
    $(window).on('load', function(){
      callback();
    });
  }
};



/*------------------------------------------------------------------------------------
  A general encapsulation to wait for a boolean property (or an object containing
  multiple booleans) to become TRUE

  An example usage scenario is to wait for critical resources to load, before calling
  some secondary / less important resources.
------------------------------------------------------------------------------------*/
window.whenTrue = function(mustBeTrue, callback) {

  // Handle an object (every key must be TRUE to pass)
  if (typeof mustBeTrue === 'object') {

    // Empty object will qualify automatically as TRUE
    if (Object.keys(mustBeTrue).length !== 0) {
      for (var property in mustBeTrue) {
        if (mustBeTrue.hasOwnProperty(property)) {
          if (mustBeTrue[property] !== true) {
            setTimeout(function(){
              whenTrue(mustBeTrue, callback);
            }, 50);
            return false;
          }
        }
      }
    }

    // If everything passes up to here, callback
    callback();
    return false;
  }

  // Handle a direct boolean
  else if (typeof mustBeTrue === boolean) {
    if (mustBeTrue === true) {
      callback();
      return false;
    } else {
      setTimeout(function(){
        whenTrue(mustBeTrue, callback);
      }, 50);
      return false;
    }
  }

  else {
    console.error('whenTrue(); ERROR: Incompatible value type!');
    return false;
  }
};



/*------------------------------------------------------------------------------------
  Get active media query
------------------------------------------------------------------------------------*/
App.checkMediaQuery = function (query, explicit) {
  all = [];

  // Default to coarse
  var explicit = explicit || false;

  // Get all active media queries
  if ($('#screenSize').css('font-family') != undefined) {
    var all = $('#screenSize').css('font-family').replace(/['"]+/g, '').split(', ');
    var last = all[all.length-1];
  }

  // Check for matches
  if( explicit === true && all[all.length-1] === query ){ return true; }
  else if( explicit === false ){
    for (var i = 0; i < all.length; i++) {
      if( all.indexOf(query) > -1 === true ){ return true; }
    }
  }

  // If no success is returned, return false
  return false;
}



/*------------------------------------------------------------------------------------
  Light scroll
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightScroll = function(callback, delay){
  var timer,
      delay = delay || 80,
      scrollCounter = 0;

  // Listen for scroll events on window and any custom scrollable element
  $(window).on('scroll touchmove', function(e) { parseScroll(e); });
  $('[data-scrollable]').on('scroll touchmove', function(e) { parseScroll(e); });

  // Main parsing function
  function parseScroll(e) {

    // Log that user has scrolled at least once
    ux.events.userHasScrolled = true;

    // Count scroll ticks and force callback execution on a specific count
    scrollCounter++;
    if( scrollCounter > 8 ){
      requestAnimationFrame(callback);
      scrollCounter = 0;
      timer = false;
      return false;
    }

    // If scroll counters are low, proceed with regular Timeout
    clearTimeout(timer);
    timer = setTimeout(function(){
      scrollCounter = 0;
      requestAnimationFrame(callback);
    }, delay);
  }
};



/*------------------------------------------------------------------------------------
  Light resize
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightResize = function(callback, delay) {
  var timer;
  var delay = delay || 100;
  $(window).on('resize', function(e) {
    clearTimeout(timer);
    timer = setTimeout(function(){
      requestAnimationFrame(callback);
    }, delay);
  });
};



/*------------------------------------------------------------------------------------
  Update user info on resize event
------------------------------------------------------------------------------------*/
App.getViewportMetadata = function(){

  // Width & Height (IE9+)
  // Do not use jQuery here as it does not account for iOS url bar dynamic height!!
  ux.viewport.width = window.innerWidth;
  ux.viewport.height = window.innerHeight;

  // Visible range
  ux.viewport.visible = {
    from: ux.scroll.offset,
    to: ux.scroll.offset + ux.viewport.height
  };

  // Check #screenSize element validity
  if ($('#screenSize').css('font-family') === undefined) {
    console.error('App.getViewportMetadata(): Unable to read screen size! Check the #screenSize element');
    return false;
  }

  // Current screen size (media query)
  var all = $('#screenSize').css('font-family').replace(/['"]+/g, '').split(', ');
  var last = all[all.length-1];
  ux.screenSize.explicit = last;

  // Coarse screen size ignores sub-sizes. This makes e.g., "smallPlus" a more general "small" size.
  if ( App.checkMediaQuery('small') === true ){ ux.screenSize.coarse = 'small'; }
  if ( App.checkMediaQuery('medium') === true ){ ux.screenSize.coarse = 'medium'; }
  if ( App.checkMediaQuery('large') === true ){ ux.screenSize.coarse = 'large'; }

}

// Get initial viewportMetadata on documentLoad
whenReady(function viewportMetadata(){
  App.getViewportMetadata();
});

// Update viewportMetadata on resize
App.lightResize(App.getViewportMetadata, 40);



/*------------------------------------------------------------------------------------
  Update user info on scroll event
------------------------------------------------------------------------------------*/
App.getScrollMetadata = function(){
  var treshold = 50;

  // Set scroll offset
  ux.scroll.offsetPrevious = ux.scroll.offset;
  ux.scroll.offset = $(window).scrollTop();

  // We compare distance traveled with a defined treshold and report scroll direction
  if( (ux.scroll.offset - ux.scroll.offsetPrevious) > treshold ){
    ux.scroll.direction = 'down';
  } else if( (ux.scroll.offsetPrevious - ux.scroll.offset) > treshold ){
    ux.scroll.direction = 'up';
  }

  // Update viewport visibility values
  ux.viewport.visible = {
    from: ux.scroll.offset,
    center: ux.scroll.offset + (ux.viewport.height / 2),
    to: ux.scroll.offset + ux.viewport.height
  };
}

// Get initial scrollMetadata on documentLoad
queue.documentLoad.push(function scrollMetadata(){
  App.getScrollMetadata();
});

// Update scrollMetadata on scroll
App.lightScroll(App.getScrollMetadata, 15);



/*------------------------------------------------------------------------------------
  Get scrollbar width
------------------------------------------------------------------------------------*/
queue.documentLoad.push(function scrollbarWidth(){

  // Create test elements
  var parent = $('<div style="width:100px;height:100px;overflow-y:scroll;visibility:hidden;"><div style="width:100%;"><div/></div>').appendTo('body');
  var child = parent.children().first();

  // Calculate scrollbar width
  ux.scroll.scrollbarWidth = 100 - child.width();

  // Calculate scrollbar position (right-to-left languages have scrollbar on the other side)
  if (child.offset().left !== parent.offset().left) {
    ux.scroll.scrollbarPosition = 'left';
  } else {
    ux.scroll.scrollbarPosition = 'right';
  }

  // Remove DOM elements
  parent.remove();
});



/*------------------------------------------------------------------------------------
  Check if element is currently visible on the screen
------------------------------------------------------------------------------------*/
App.checkIfVisible = function(el, tresholdMultiplier) {

  // Default treshold and multiplier
  var tresholdMultiplier = tresholdMultiplier || 1;
  var treshold = ux.viewport.height * tresholdMultiplier;

  // Increase the treshold even further for smaller devices, since the user will
  // usually be scrolling much faster.
  if (
    App.checkMediaQuery('small', true) === true ||
    App.checkMediaQuery('smallPlus', true) === true ||
    App.checkMediaQuery('medium', true) === true
  ){
    treshold = treshold * 1.5;
  }

  // Additionally, increase the treshold if device is in landscape mode
  if (ux.viewport.width > (ux.viewport.height * 2)) {
    treshold = treshold * 1.5;
  }

  var elem = {
    offset: $(el).offset(),
    width: $(el).width(),
    height: $(el).height()
  };

  if (
    (elem.offset.top + elem.height) >= (ux.scroll.offset - treshold) &&
    elem.offset.top <= (ux.viewport.visible.to + treshold)
  ){
    return true;
  } else {
    return false;
  }
}
