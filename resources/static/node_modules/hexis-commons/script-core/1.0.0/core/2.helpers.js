/*------------------------------------------------------------------------------------
  requestAnimationFrame polyfill
------------------------------------------------------------------------------------*/
window.requestAnimationFrame = window.requestAnimationFrame
  || window.webkitRequestAnimationFrame
  || window.mozRequestAnimationFrame
  || window.msRequestAnimationFrame
  || function(callback) { return setTimeout(callback, 1000 / 60); };



/*------------------------------------------------------------------------------------
  Get active media query
------------------------------------------------------------------------------------*/
App.checkMediaQuery = function (query, explicit) {
  all = [];

  // Default to coarse
  var explicit = explicit || false;

  // Get all active media queries
  if ($('#screenSize').css('font-family') != undefined) {
    var all = $('#screenSize').css('font-family').replace(/['"]+/g, '').split(', ');
    var last = all[all.length-1];
  }

  // Check for matches
  if( explicit === true && all[all.length-1] === query ){ return true; }
  else if( explicit === false ){
    for (var i = 0; i < all.length; i++) {
      if( all.indexOf(query) > -1 === true ){ return true; }
    }
  }

  // If no success is returned, return false
  return false;
}



/*------------------------------------------------------------------------------------
  Light scroll
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightScroll = function(callback, delay){
  var timer,
      delay = delay || 80,
      scrollCounter = 0;

  $(window).on('scroll', function(e) {

    // Log that user has scrolled at least once
    ux.events.userHasScrolled = true;

    // Count scroll ticks and force callback execution on a specific count
    scrollCounter++;
    if( scrollCounter > 8 ){
      requestAnimationFrame(callback);
      scrollCounter = 0;
      timer = false;
      return false;
    }

    // If scroll counters are low, proceed with regular Timeout
    clearTimeout(timer);
    timer = setTimeout(function(){
      scrollCounter = 0;
      requestAnimationFrame(callback);
    }, delay);

  });
};



/*------------------------------------------------------------------------------------
  Light resize
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightResize = function(callback, delay) {
  var timer;
  var delay = delay || 100;
  $(window).on('resize', function(e) {
    clearTimeout(timer);
    timer = setTimeout(function(){
      requestAnimationFrame(callback);
    }, delay);
  });
};



/*------------------------------------------------------------------------------------
  Update user info on resize event
------------------------------------------------------------------------------------*/
App.getViewportMetadata = function(){

  // Width & Height
  ux.viewport.width = $(window).width();
  ux.viewport.height = $(window).height();

  // Visible range
  ux.viewport.visible = {
    from: ux.scroll.offset,
    to: ux.scroll.offset + ux.viewport.height
  };

  // Current screen size (media query)
  var all = $('#screenSize').css('font-family').replace(/['"]+/g, '').split(', ');
  var last = all[all.length-1];
  ux.screenSize.explicit = last;

  // Coarse screen size ignores sub-sizes. This makes e.g., "smallPlus" a more general "small" size.
  if ( App.checkMediaQuery('small') === true ){ ux.screenSize.coarse = 'small'; }
  if ( App.checkMediaQuery('medium') === true ){ ux.screenSize.coarse = 'medium'; }
  if ( App.checkMediaQuery('large') === true ){ ux.screenSize.coarse = 'large'; }

}

// Get initial viewportMetadata on documentLoad
queue.documentLoad.push(function viewportMetadata(){
  App.getViewportMetadata();
});

// Update viewportMetadata on resize
App.lightResize(App.getViewportMetadata, 40);



/*------------------------------------------------------------------------------------
  Update user info on scroll event
------------------------------------------------------------------------------------*/
App.getScrollMetadata = function(){
  var treshold = 50;

  // Set scroll offset
  ux.scroll.offsetPrevious = ux.scroll.offset;
  ux.scroll.offset = $(window).scrollTop();

  // We compare distance traveled with a defined treshold and report scroll direction
  if( (ux.scroll.offset - ux.scroll.offsetPrevious) > treshold ){
    ux.scroll.direction = 'down';
  } else if( (ux.scroll.offsetPrevious - ux.scroll.offset) > treshold ){
    ux.scroll.direction = 'up';
  }

  // Update viewport visibility values
  ux.viewport.visible = {
    from: ux.scroll.offset,
    center: ux.scroll.offset + (ux.viewport.height / 2),
    to: ux.scroll.offset + ux.viewport.height
  };
}

// Get initial scrollMetadata on documentLoad
queue.documentLoad.push(function scrollMetadata(){
  App.getScrollMetadata();
});

// Update scrollMetadata on scroll
App.lightScroll(App.getScrollMetadata, 15);


/*------------------------------------------------------------------------------------
  Check if element is currently visible on the screen
------------------------------------------------------------------------------------*/
App.checkIfVisible = function(el) {
  var elOffset = el.offset().top;
  var elHeight = el.height();

  if ( ux.viewport.visible.to < elOffset || ux.viewport.visible.from > (elOffset + elHeight) ){
    return false;
  } else {
    return true;
  }
}


/*------------------------------------------------------------------------------------
  Check if element is near the bottom of the screen
------------------------------------------------------------------------------------*/
// App.checkIfNearBottom = function(elem, offset) {
//   var docViewBottom = ux.viewport.scroll.top + ux.viewport.height;
//   var elemTop = elem.offset().top;
//   var offset = offset | 0;
//   return( (elemTop + offset) <= docViewBottom );
// }
