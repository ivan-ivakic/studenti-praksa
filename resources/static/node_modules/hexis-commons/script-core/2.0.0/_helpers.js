/*------------------------------------------------------------------------------------
  Finds the first matched parent in native javascript.
  Similar to jQuery.closest();

  - First you provide a starting point / target element (usually event.target)
  - You must specify a wanted selector for the parent, e.g. "div.class" or an array
    of selectors like ['.selector1', '#selector2', '[selector3]']
  - You can be performant and specify an optional limiterSelector. Without it, this
    will check for matches all the way up to the root/body element
  - If matched, returns the element itself
  - If not matched, return false
------------------------------------------------------------------------------------*/
function closest(target, wantedSelector, limiterSelector) {
  var current = target;
  var limiterSelector = limiterSelector || 'body';
  var match = false;

  // Iterate through parent elements until you reach some end
  while (match === false) {

    // If this is the bubbling limit...
    if (current.matches(limiterSelector)===true || current.matches('body')===true) {
      if (current.matches(wantedSelector)===true) {
        match = current;
      } else {
        return false;
      }
    }

    // Simple string match first...
    if (typeof wantedSelector==='string' && current.matches(wantedSelector)===true) {
      match = current;
    }

    // In case, we're dealing with an array of possible matches, check each selector individually..
    else if (typeof wantedSelector==='object') {
      wantedSelector.forEach(function(currentSelector){
        if (current.matches(currentSelector)===true) {
          match = current;
        }
      });
    }

    // If no matches, move up the parent tree...
    current = current.parentElement;
  }

  // If everything so far passes, return the element
  return match;
}



/*------------------------------------------------------------------------------------
  Simple NodeList to array conversion
------------------------------------------------------------------------------------*/
window.array = function(NodeList) {
  return Array.prototype.slice.call(NodeList);
}



/*------------------------------------------------------------------------------------
  Simple append / prepend functions.
  Accepts html string, e.g. "<div class='foo'>bar</div>"
------------------------------------------------------------------------------------*/
function appendix(html) {
  if (typeof html === 'string') {
    var p = document.createElement('div');
    p.innerHTML = html;
    return array(p.children);
  }
  else if (typeof html === 'object') {
    return [html];
  }
}

window.append = function(html, targetElement) {
  appendix(html).forEach(function(node){
    targetElement.appendChild(node);
  });
}

window.prepend = function(html, targetElement) {
  appendix(html).forEach(function(node){
    targetElement.insertBefore(node, targetElement);
  });
}



/*------------------------------------------------------------------------------------
  Encapsulation to make sure your callback code runs only if/when documentReady
  or windowLoad event has fired (even after it has passed)
------------------------------------------------------------------------------------*/
window.whenReady = function(callback) {
  if (App.documentReady === true) {
    callback();
  } else {
    setTimeout(function(){
      whenReady(callback);
    }, 50);
  }
};

window.whenLoaded = function(callback) {
  if (App.windowLoad === true) {
    callback();
  } else {
    setTimeout(function(){
      whenLoaded(callback);
    }, 100);
  }
};



/*------------------------------------------------------------------------------------
  A general encapsulation to wait for a boolean property (or an object containing
  multiple booleans) to become TRUE

  An example usage scenario is to wait for critical resources to load, before calling
  some secondary / less important resources.
------------------------------------------------------------------------------------*/
window.whenTrue = function(path, callback) {
  var callback = callback || function(){};
  var loadPath = path.split('.');
  var mustBeTrue;

  // ARE YOU NOT ENTERTAINED !?
  if (loadPath.length === 1) {
    mustBeTrue = App.load[loadPath[0]];
  } else if (loadPath.length === 2) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]];
  } else if (loadPath.length === 3) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]][loadPath[2]];
  } else if (loadPath.length === 4) {
    mustBeTrue = App.load[loadPath[0]][loadPath[1]][loadPath[2]][loadPath[3]];
  } else if (loadPath.length > 4) {
    console.error('whenTrue(); ERROR: Entertainment level is too damn high!');
  }

  // We use an external function to do this specific work and call back if it return true
  if (ifTrue(mustBeTrue)) {
    callback();
  }

  // Otherwise, we check back here again after a delay
  else {
    setTimeout(function(){
      whenTrue(path, callback);
    }, 50);
  }
};


window.ifTrue = function(mustBeTrue) {

  // Handle an object (every key must be TRUE to pass)
  if (typeof mustBeTrue === 'object') {

    // Empty object will qualify automatically as TRUE
    if (Object.keys(mustBeTrue).length !== 0) {
      for (var property in mustBeTrue) {
        if (mustBeTrue.hasOwnProperty(property)) {
          if (mustBeTrue[property] !== true) {
            return false;
          }
        }
      }
    }

    // If everything passes up to here, return true
    return true;
  }

  // Handle a direct boolean
  else if (typeof mustBeTrue === 'boolean') {
    if (mustBeTrue === true) {
      return true;
    } else {
      return false;
    }
  }

  // String is not allowed
  else if (typeof mustBeTrue === 'string') {
    console.error('whenTrue(); ERROR: String is not allowed. Must be a boolean or object...');
    return false;
  }

  // Fallback error
  else {
    console.error('whenTrue(); ERROR: Incompatible value type!');
    return false;
  }
};



/*------------------------------------------------------------------------------------
  Light scroll
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightScroll = function(callback, delay){
  var timer,
      delay = delay || 80,
      scrollCounter = 0;

  // Listen for scroll and touchmove events and parse them...
  window.addEventListener('scroll', function(e){
    parseScroll(e);
  }, true);
  window.addEventListener('touchmove', function(e){
    parseScroll(e);
  }, true);

  // Parsing function
  function parseScroll(e) {

    // Log that user has scrolled at least once
    ux.events.userHasScrolled = true;

    // Count scroll ticks and force callback execution on a specific count
    scrollCounter++;
    if( scrollCounter > 8 ){
      requestAnimationFrame(callback);
      scrollCounter = 0;
      timer = false;
      return false;
    }

    // If scroll counters are low, proceed with regular Timeout
    clearTimeout(timer);
    timer = setTimeout(function(){
      scrollCounter = 0;
      requestAnimationFrame(callback);
    }, delay);
  }
};



/*------------------------------------------------------------------------------------
  Light resize
  - Triggers with a delay, not instantly, therefore is less intensive on the cpu
  - Callbacks on requestAnimationFrame for additional performance
------------------------------------------------------------------------------------*/
App.lightResize = function(callback, delay) {
  var timer;
  var delay = delay || 100;
  window.addEventListener('resize', function(){
    clearTimeout(timer);
    timer = setTimeout(function(){
      requestAnimationFrame(callback);
    }, delay);
  });
};



/*------------------------------------------------------------------------------------
  Update user info on scroll event
------------------------------------------------------------------------------------*/
App.getScrollMetadata = function(){
  var treshold = 50;

  // Set scroll offset
  ux.scroll.offsetPrevious = ux.scroll.offset;
  ux.scroll.offset = document.documentElement.scrollTop || document.body.scrollTop;

  // We compare distance traveled with a defined treshold and report scroll direction
  if( (ux.scroll.offset - ux.scroll.offsetPrevious) > treshold ){
    ux.scroll.direction = 'down';
  } else if( (ux.scroll.offsetPrevious - ux.scroll.offset) > treshold ){
    ux.scroll.direction = 'up';
  }

  // Update viewport visibility values
  ux.viewport.visible = {
    from: ux.scroll.offset,
    center: ux.scroll.offset + (ux.viewport.height / 2),
    to: ux.scroll.offset + ux.viewport.height
  };
}

// Get initial scrollMetadata on documentLoad
whenReady(function scrollMetadata(){
  App.getScrollMetadata();
});

// Update scrollMetadata on scroll
App.lightScroll(App.getScrollMetadata, 20);



/*------------------------------------------------------------------------------------
  Update user info on resize event
------------------------------------------------------------------------------------*/
App.getViewportMetadata = function(){

  // Refresh scroll metadata first
  App.getScrollMetadata();

  // Find the helper element
  var screenHelper = document.getElementById('screenSize');

  // Return error if no helper element is found
  if (screenHelper===null || screenHelper===undefined) {
    console.error('App.getViewportMetadata(): Unable to read screen size! Check the #screenSize element');
    return false;
  }

  // Get dimensions
  // We don't check "window" for screen size due to iOS browser bugs
  ux.viewport.width = screenHelper.offsetWidth;
  ux.viewport.height = screenHelper.offsetHeight;

  // Parse and store device sizes
  var rawSizes = window.getComputedStyle(screenHelper).getPropertyValue('font-family');
  ux.screenSize.all = rawSizes.replace(/['"]+/g, '').split(', ');
  ux.screenSize.last = ux.screenSize.all[ux.screenSize.all.length-1];
}

// Get initial viewportMetadata on documentLoad
whenReady(function viewportMetadata(){
  App.getViewportMetadata();
});

// Update viewportMetadata on resize
App.lightResize(App.getViewportMetadata, 40);



/*------------------------------------------------------------------------------------
  Get active media query
------------------------------------------------------------------------------------*/
App.checkMediaQuery = function (query, explicit) {

  // Default to coarse
  var explicit = explicit || false;

  // Check for matches
  if( explicit === true && ux.screenSize.all[ux.screenSize.all.length-1] === query ){ return true; }
  else if( explicit === false ){
    for (var i = 0; i < ux.screenSize.all.length; i++) {
      if( ux.screenSize.all.indexOf(query) > -1 === true ){ return true; }
    }
  }

  // If no success is returned, return false
  return false;
}


/*------------------------------------------------------------------------------------
  Get scrollbar width
------------------------------------------------------------------------------------*/
whenReady(function scrollbarWidth(){

  // Create a tester element
  var html = '<div id="scrollTester" style="width:100px;height:100px;overflow-y:scroll;visibility:hidden;"><div style="width:100%;"><div/></div>';
  append(html, document.body);

  // Anchor working elements
  var tester = document.getElementById('scrollTester');
  var child = tester.querySelector('div');

  // Calculate scrollbar width
  ux.scroll.scrollbarWidth = 100 - child.offsetWidth;

  // Calculate scrollbar position (right-to-left languages have scrollbar on the other side)
  if (tester.getBoundingClientRect().left !== child.getBoundingClientRect().left) {
    ux.scroll.scrollbarPosition = 'left';
  } else {
    ux.scroll.scrollbarPosition = 'right';
  }

  // Remove the tester from the DOM
  document.body.removeChild(tester);
});



/*------------------------------------------------------------------------------------
  Check if element is currently visible on the screen
------------------------------------------------------------------------------------*/
App.checkIfVisible = function(el, tresholdMultiplier) {

  // Default treshold and multiplier
  var tresholdMultiplier = tresholdMultiplier || 1;
  var treshold = ux.viewport.height * tresholdMultiplier;

  // Increase the treshold even further for smaller devices, since the user will
  // usually be scrolling much faster.
  if (
    App.checkMediaQuery('small', true) === true ||
    App.checkMediaQuery('smallPlus', true) === true ||
    App.checkMediaQuery('medium', true) === true
  ){
    treshold = treshold * 1.5;
  }

  // Additionally, increase the treshold if device is in landscape mode
  if (ux.viewport.width > ((ux.viewport.height) * 2)) {
    treshold = treshold * 1.5;
  }

  var bounds = el.getBoundingClientRect();

  if (
    (bounds.top + bounds.height) >= (0 - treshold) &&
    bounds.top < (ux.viewport.height + treshold)
  ){
    return true;
  } else {
    return false;
  }
}


/*------------------------------------------------------------------------------------
  setTimeout() abstraction which collapses any timeout to 0ms if the browser does
  not support css transitions
------------------------------------------------------------------------------------*/
window.animationTimeout = function(timeout, callback) {

  // Get transition support data the first time
  if (ux.support.transitions === undefined) {
    if (document.getElementsByTagName('html')[0].classList.contains('transitions')) {
      ux.support.transitions = true;
    } else {
      ux.support.transitions = false;
    }
  }

  // Make the check
  if (ux.support.transitions === true) {
    setTimeout(callback, timeout);
  } else {
    callback();
  }
}
