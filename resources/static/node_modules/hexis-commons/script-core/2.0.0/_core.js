'use strict';


/*------------------------------------------------------------------------------------
  Hide debug messages?
------------------------------------------------------------------------------------*/
if (App.debug === false) {
  var console = {
    log: function(){},
    debug: function(){},
    info: function(){},
    warn: function(){},
    error: function(){}
  };
  window.console = console;
}


/*------------------------------------------------------------------------------------
  Define some global paths
------------------------------------------------------------------------------------*/
window.path = {
  scripts: 'scripts/'
};


/*------------------------------------------------------------------------------------
  Load placeholder
------------------------------------------------------------------------------------*/
App.load = {
  critical: {},
  primary: {},
  secondary: {}
};


/*------------------------------------------------------------------------------------
  Define global ux variable
------------------------------------------------------------------------------------*/
window.ux = {
  support: {},
  screenSize: {},
  viewport: {
    visible: {}
  },
  scroll: {
    direction: false
  },
  events: {
    userHasScrolled: false
  },
  preload: {},
  func: {}
};


/*------------------------------------------------------------------------------------
  QUEUES

  ABOUT:
    In order to modularize and truly separate script components, we cannot mix calls
    and listeners all over the place. One component may need to listen to a different
    component's ajax success call, and so on. Plus, for performance reasons, it's
    better to execute once on e.g., a page resize, than to have 10 resize listeners
    and various calculations which may be CPU intensive.

    In order to solve this problem, we can store our functions in a queue, and then
    just execute the queue at specific time. This can be once on every resize tick,
    or perhaps on an ajax success/dom insert to trigger "equal-column" calc again.

  HOW TO USE:
    If you wish to add something to the e.g., resize queue, write:

    queue.pageUnload.push(function myFunctionName(){
      // This code will be executed on "pageUnload" event
    });

    ---

    This will add your function to the "globalResizeEvents" queue. Later, in some
    resize listener when you wish to execute trigger queue, write:

    queue.trigger('pageUnload');

    This will run every stored function in the queue. In the order they were added.

    ---

    To remove a function from the desired queue, use:

    queue.remove('myFunctionName', 'pageUnload');

  TIP:
    You can also create custom queue names and give them whatever names you want. If
    you need to create a new queue for you component, feel free to do so. But try to
    use existing queues if possible, to keep the list shorter.

------------------------------------------------------------------------------------*/
window.queue = {
  jQuery: [],
  pageLoad: [],
  pageUnload: [],
  globalClick: [],
  globalScroll: [],
  globalResize: [],
  domChange: [],

  // Function to execute a specific queue
  trigger: function(queueName) {
    console.log('queue.' + queueName + '();');
    queue[queueName].forEach(function(func){
      func();
    });
  },

  // Remove a function from the queue, based on its name
  remove: function(functionName, queueName) {
    queue[queueName].forEach(function(func, index){
      if (func.name === functionName) {
        queue[queueName].splice(index, 1);
        return;
      }
    });
  }
};


/*------------------------------------------------------------------------------------
  Log when documentReady and windowLoad events pass
------------------------------------------------------------------------------------*/
App.documentReady = App.documentReady || false;
App.windowLoad = App.windowLoad || false;
