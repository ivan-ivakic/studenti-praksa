App.mediaLoader = {
  debug: false,
  verbose: false,
  selector: '[data-src]',
  filter: ':not(script):not([data-delay]):not([loadedOnCurrentSize]):not([data-ignore]):not([src^="data:"])',
  loaded: [],


  /*------------------------------------------------------------------------------------
    CHECK
  ------------------------------------------------------------------------------------*/
  check: function(target) {
    if(this.debug){ console.log('%cApp.mediaLoader.check()', 'color:gray;'); }

    // Base setup
    var target = target || null;
    var localNodes;
    var offset = {};
    var toBeLoaded = [];

    // Determine if check is global or scoped
    if (target === undefined || target === null) {
      localNodes = document.querySelectorAll(App.mediaLoader.selector + App.mediaLoader.filter);
    } else {
      localNodes = target.querySelectorAll(App.mediaLoader.selector + App.mediaLoader.filter);
    }

    // Debug
    if(this.debug && this.verbose){ console.log(target, localNodes); }

    // Iterate through nodeList
    array(localNodes).forEach(function(node) {

      // Skip the delay tags
      if (node.getAttribute('data-delay') !== null && node.getAttribute('data-delay') !== undefined) { return; }

      // Load only media which is about to be visible
      var scope = node.getAttribute('data-scope') || null;
      if (App.checkIfVisible(node, scope)) {
        toBeLoaded.push(node);
      }
    });

    // Load those nodes in bulk
    toBeLoaded.forEach(function(node){
      App.mediaLoader.load(node);
    });
  },


  /*------------------------------------------------------------------------------------
    LOAD
  ------------------------------------------------------------------------------------*/
  load: function(node, callback) {
    var callback = callback || function(){};
    var pNode = App.mediaLoader.parseNode(node);
    if(this.debug && this.verbose){ console.log('%cApp.mediaLoader.load("'+ pNode.src +'")', 'color:gray;'); }

    // Get media style (if it has one)
    var style = node.getAttribute('style') || '';

    // Don't start a new load if the sources match
    var nodeSrc = node.getAttribute('src') || '';
    if (nodeSrc.indexOf(pNode.src) > -1 || pNode.styleAttr.indexOf(pNode.src) > -1) {
      pNode.status = 'done';
      App.mediaLoader.onComplete(pNode, callback);
      return;
    }

    // Mark node as loading...
    pNode.el.setAttribute('loading', '');

    // Handle native elements
    if (pNode.isNative) {
      pNode.el.onload = function(){ pNode.status='done'; App.mediaLoader.onComplete(pNode, callback); };
      pNode.el.onerror = function(){ pNode.status='error'; App.mediaLoader.onComplete(pNode, callback); };

      // Streaming media should load with enough buffer to play, but not loaded completely
      if (pNode.isStreamingMedia) {

        // Maybe we have to show the fallback poster instead of a video?
        console.log(pNode.src, pNode.fallbackSrc);
        if (pNode.src === '#blank' && pNode.fallbackSrc !== null) {
          pNode.el.src = pNode.src;
          pNode.el.setAttribute('poster', pNode.fallbackSrc);
          pNode.status='done';
          App.mediaLoader.onComplete(pNode, callback);
          return;
        }

        // Otherwise proceed normally...
        else {
          var listener = function(){
            pNode.status = 'done';
            App.mediaLoader.onComplete(pNode, callback);
            pNode.el.removeEventListener('canplay', listener);
          };
          if(pNode.readyState > 2) { listener(); }
          else { pNode.el.addEventListener('canplay', listener); }
        }
      }

      pNode.el.src = pNode.src;
      return;
    }

    // Non-native elements need a shadow image to improvise load event
    else {
      var shadowImage = new Image();
      shadowImage.onload = function(){
        pNode.status = 'done';
        shadowImage = null;
        App.mediaLoader.onComplete(pNode, callback);
      };
      shadowImage.onerror = function(){
        pNode.status = 'error';
        shadowImage = null;
        App.mediaLoader.onComplete(pNode, callback);
      };

      // Start the call...
      shadowImage.src = pNode.src;

      // Add the matched source as background image
      var newStyle = 'background-image:url("'+ pNode.src +'")';
      if (pNode.styleAttr !== null) { newStyle = pNode.styleAttr + newStyle; }
      pNode.el.setAttribute('style', newStyle);
    }
  },


  /*------------------------------------------------------------------------------------
    PARSE NODE
  ------------------------------------------------------------------------------------*/
  parseNode: function(node, callback) {
    var callback = callback || function(){};
    var nativeElements = ['img', 'video', 'audio', 'source', 'iframe'];

    // Parser object
    var pNode = {};
      pNode.el = node;
      pNode.tag = node.tagName.toLowerCase();
      pNode.src = '#blank'; // Default, blank src is a valid hashtag
      pNode.styleAttr = node.getAttribute('style') || '';
      pNode.nativeSrc = node.getAttribute('src');
      pNode.fallbackSrc = node.getAttribute('data-fallback');
      pNode.dataSrc = App.mediaLoader.parseSrc(node.getAttribute('data-src'));
      pNode.delay = pNode.el.getAttribute('data-delay');
      pNode.isNative = (nativeElements.indexOf(pNode.tag) > -1);
      pNode.isStreamingMedia = (['audio', 'video'].indexOf(pNode.tag) > -1);
      pNode.isSimpleSrc = (pNode.dataSrc.length === 1);
      pNode.isLoadedOnCurrentSize = (pNode.el.getAttribute('loadedOnCurrentSize') !== null && pNode.el.getAttribute('loadedOnCurrentSize') !== undefined);
      pNode.isAlreadyLoaded = false;

    // Element has a src, but no data-src attribute?
    if (pNode.nativeSrc !== null && pNode.nativeSrc !== '' && pNode.dataSrc === false) {
      pNode.isAlreadyLoaded = (App.mediaLoader.loaded.indexOf(pNode.nativeSrc) > -1 || pNode.el.complete === true);
      pNode.src = pNode.nativeSrc;
    }

    // If there is only one file in data-src, then we do not check anything further
    if (pNode.isSimpleSrc) {
      pNode.src = pNode.dataSrc[0].src;
    }

    // Otherwise, determine which of the multiple sources matches
    else if (pNode.isLoadedOnCurrentSize === false) {
      for(var i=pNode.dataSrc.length-1; i>=0; i--){

        // If the source has no conditions, then it is loaded by default
        if (pNode.dataSrc[i].conditions.length < 1 && pNode.src === '#blank') {
          pNode.src = pNode.dataSrc[i].src;
        }

        // Otherwise, check if all conditions match
        else if (App.mediaLoader.checkConditions(pNode.dataSrc[i].conditions) === true  && pNode.src === '#blank') {
          pNode.src = pNode.dataSrc[i].src;
        }
      };
    }

    return pNode;
  },


  /*------------------------------------------------------------------------------------
    PARSE DATA-SRC ARRAY
  ------------------------------------------------------------------------------------*/
  parseSrc: function(dataSrc) {
    if (dataSrc === null) { return false; }

    var cleaned = dataSrc.replace(/\[/g, '').replace(/\]/g, '').replace(/  /g, '').replace(/  /g, '').replace(/, /g, ',').replace(/(\r\n|\n|\r)/gm,"");
    var sets = cleaned.split(',');
    var parsedSrc = [];

    sets.forEach(function(node, i){
      var params = node.split(' -');
      var conditions = params.splice(1, params.length-1);
      parsedSrc.push({
        src: App.mediaPath + params[0],
        conditions: conditions
      });
    });

    return parsedSrc;
  },


  /*------------------------------------------------------------------------------------
    CHECK IF ALL CONDITIONS MATCH
  ------------------------------------------------------------------------------------*/
  checkConditions: function(conditions) {
    var matchedConditions = 0;

    conditions.forEach(function(cond){
      if (App.checkMediaQuery(cond) === true) {
        matchedConditions++;
      }
    });

    if (matchedConditions === conditions.length) { return true; }
    else { return false; }
  },


  /*------------------------------------------------------------------------------------
    SINGLE NODE FINISHES LOADING
  ------------------------------------------------------------------------------------*/
  onComplete: function(pNode, callback) {

    if (pNode.status === 'done') {
      if(this.debug && this.verbose){ console.log('%cApp.mediaLoader.done("'+ pNode.src +'")', 'color:#68B046;'); }
      App.mediaLoader.loaded.push(pNode.src);
    } else {
      if(this.debug && this.verbose){ console.error('App.mediaLoader.done("'+ pNode.src +'") 404'); }
      pNode.el.setAttribute('loadError', '');
    }

    // Node is no longer loading...
    pNode.el.removeAttribute('loading', '');
    pNode.el.removeAttribute('data-delay', '');

    // Check if we need to fade in the media after it has loaded
    if (pNode.el.getAttribute('data-fadeIn') !== null) {
      pNode.el.removeAttribute('nodeIsLoading');
      pNode.el.setAttribute('fadeInStarted', '');
      animationTimeout(320, function(){
        pNode.el.removeAttribute('data-fadeIn');
        pNode.el.removeAttribute('fadeInStarted');
      });
    }

    // On single sources, disable further checks. There are no alternatives anyways [performance]
    if (pNode.isSimpleSrc) {
      pNode.el.setAttribute('data-ignore', '');
    }

    // On multiple sources, ignore further checks until the viewport changes size [performance]
    else {
      pNode.el.setAttribute('loadedOnCurrentSize', '');
    }

    // Mark node as loaded
    pNode.el.setAttribute('loaded', '');

    // Run callback function asynchronously
    setTimeout(callback, 50);
  },


  /*------------------------------------------------------------------------------------
    WAIT FOR ALL (TO LOAD)
  ------------------------------------------------------------------------------------*/
  waitForAll: function(target, callback, delayPriority) {
    var t = this;
    var nodesLoaded = 0;
    var delayPriority = delayPriority || 0;
    var filter = '';
    var localNodes = [];
    var guid = App.guid();
    var timeoutDuration = 20000;
    var callback = App.callback(callback);

    // Check for common errors
    if (typeof target === 'function') {
      console.error('%cApp.mediaLoader.waitForAll(); ERROR: First parameter cannot be a function!', 'color:red;');
      return false;
    }

    // If target is only a selector, find the target first...
    if (typeof target === 'string') {
      target = document.querySelectorAll(target);
    }

    // Decide if delayed nodes are also counted
    if (delayPriority === 0) {
      filter = this.filter;
    } else {
      filter = ':not(script):not([loadedOnCurrentSize]):not([data-ignore]):not([src^="data:"])';
    }

    // If target is an array of objects, we concatenate all of their results
    if (target[0]) {
      array(target).forEach(function(node){
        var newNodes = array(node.querySelectorAll(App.mediaLoader.selector + filter + ', [src]' + filter));
        localNodes = localNodes.concat(newNodes);
      });
    }

    // Otherwise, just must a single call...
    else {
      localNodes = array(target.querySelectorAll(App.mediaLoader.selector + filter + ', [src]' + filter));
    }

    // If there is no defined priority, we exclude every preload element
    if (delayPriority > 0) {
      var defaults = [];
      var priority1 = [];
      var priority2 = [];
      var priority3 = [];
      var priority4 = [];

      // Iterate through each node...
      localNodes.forEach(function(node){
        var itemPriority = parseInt(node.getAttribute('data-delay')) || 0;

        // Exclude items which are higher priority than requested
        // And sort items in order of priority
        if (itemPriority <= delayPriority && (node.getAttribute('data-ignore') === null)) {
          if (itemPriority === 0) { priority1.push(node); }
          else if (itemPriority === 1) { priority1.push(node); }
          else if (itemPriority === 2) { priority2.push(node); }
          else if (itemPriority === 3) { priority3.push(node); }
          else if (itemPriority === 4) { priority3.push(node); }
          else if (itemPriority === 5) { priority3.push(node); }
          else if (itemPriority > 5) { priority4.push(node); }
        }
      });

      localNodes = defaults.concat(priority1, priority2, priority3, priority4);
    }

    // Log the number of nodes...
    if(t.debug && t.verbose){ console.log('App.mediaLoader.waitForAll('+ localNodes.length +')', localNodes); }
    else if (t.debug) { console.log('App.mediaLoader.waitForAll('+ localNodes.length +')'); }

    // If idler is included, block it until everything finishes loading
    if(window.idle){ idle.block(guid); }

    // If this scope does not have any matched nodes, then callback immediatelly
    if (localNodes.length === 0) {
      console.log('%cApp.mediaLoader.waitForAll.done(); No images were found within this selector!', 'color:#68B046;');
      callback();
      if(window.idle){ idle.unblock(guid); }
      return;
    }

    function checkIfAll() {
      if(t.debug && t.verbose){
        console.log('App.mediaLoader.checkIfAll()', nodesLoaded, localNodes.length);
        console.log(localNodes);
      }
      if (nodesLoaded >= localNodes.length) {
        console.log('%cApp.mediaLoader.waitForAll.done('+ localNodes.length +')', 'color:#68B046;');
        setTimeout(function(){
          callback();
          if(window.idle){ idle.unblock(guid); }
        }, 0);
        return;
      }
    }

    // Call every node source
    array(localNodes).forEach(function(node){

      // Create a timeout for this instance
      var timer = setTimeout(function(){
        console.error('App.mediaLoader.waitForAll(); Node timeout after ' + timeoutDuration + 'ms', node);
        nodesLoaded++;
        checkIfAll();
      }, timeoutDuration);

      // Initiate the load
      App.mediaLoader.load(node, function(){
        clearTimeout(timer);
        nodesLoaded++;
        checkIfAll();
      });
    });
  }
};


// Do an initial check
whenReady(function App_mediaLoader_checkOnReady(){
  App.mediaLoader.check();
});


// Check on scroll
queue.globalScroll.push(function App_mediaLoader_checkOnScroll(){
  App.mediaLoader.check();
});


// Check on resize
queue.globalResize.push(function App_mediaLoader_checkOnResize(){
  array(document.querySelectorAll('[loadedOnCurrentSize]')).forEach(function(node){
    node.removeAttribute('loadedOnCurrentSize');
  });
  App.mediaLoader.check();
});


// Check on DOM change
queue.domChange.push(function App_mediaLoader_checkOnDOM(){
  App.mediaLoader.check();
});
